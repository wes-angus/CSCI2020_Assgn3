/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

import javax.swing.JPanel;
import java.awt.Graphics;
import java.awt.Color;
import java.awt.Font;
import java.awt.Dimension;
import java.awt.FontMetrics;
import java.util.ArrayList;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;

/**
 *
 * @author 100449718
 */
public class LineGraph extends JPanel {

    /**
     * Creates new form LineGraph
     */
    List<Double> lineValues;
    List<String> lineLabels;
    int yStepSize;
    
    public LineGraph(Map<String, Double> values, int y_step_size)
    {
        lineValues = new ArrayList<>();
        lineLabels = new ArrayList<>();
        Map<String, Double> labelToValueMap = new LinkedHashMap<>(values);
        for(Map.Entry<String, Double> entry : labelToValueMap.entrySet())
        {
            lineLabels.add(entry.getKey());
            lineValues.add(entry.getValue());
        }
        yStepSize = y_step_size;
        initComponents();
    }

    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        jLabel1 = new javax.swing.JLabel();

        setPreferredSize(new java.awt.Dimension(1280, 720));
        setRequestFocusEnabled(false);

        jLabel1.setFont(new java.awt.Font("Trajan Pro", 1, 14)); // NOI18N
        jLabel1.setText("Legend");

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(this);
        this.setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, layout.createSequentialGroup()
                .addContainerGap(697, Short.MAX_VALUE)
                .addComponent(jLabel1)
                .addGap(204, 204, 204))
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addGap(64, 64, 64)
                .addComponent(jLabel1)
                .addContainerGap(641, Short.MAX_VALUE))
        );
    }// </editor-fold>//GEN-END:initComponents

    @Override
    protected void paintComponent(Graphics g)
    {
        Color[] colors = {Color.blue, Color.green, Color.magenta, Color.orange, Color.yellow, Color.cyan, Color.pink, Color.red, Color.gray};
        //find longest bar to fit graph to
        int min = 100000;
        double max = (double)min;
        for(double value : lineValues)
        {
            max = Math.max(max, value);
        }
        int maxInt = (int) Math.rint(max);
        
        Dimension d = getPreferredSize();
        int clientHeight = d.height;
        int clientWidth = d.width;
        
        Font labelFont = new Font("SansSerif", Font.PLAIN, 10);
        FontMetrics labelFontMetrics = g.getFontMetrics(labelFont);
        g.setFont(labelFont);
        Font legendFont = new Font("Verdana", Font.BOLD, 12);
        FontMetrics legendFontMetrics = g.getFontMetrics(labelFont);
        int sideOffset = labelFontMetrics.stringWidth("$" + Integer.toString(maxInt)) + 10;
        int otherSideOffset = 480;
        double lineSpacing = ((double)clientWidth - (double)sideOffset - (double)otherSideOffset) / ((double)lineValues.size() - 1.0);
        
        int topOffset = 10;
        int bottomOffset = labelFontMetrics.getHeight() + 5;
        int rectX = clientWidth - 440;
        int rectY = 90;
        int rectHeight = 540;
        int rectWidth = 400;
        int valueX;
        int valueY;
        int valueX2;
        int valueY2;
        int legendPosY;
        int l_x;
        int l_y = clientHeight - 3;
        int labelWidth;
        
        double scale = ((double)clientHeight - (double)topOffset - (double)bottomOffset) / (max - min);
        
        for (int i = 0; i + 1 < lineValues.size(); i++)
        {
            valueX = (int) ((double)i * (lineSpacing)) + sideOffset;
            valueY = topOffset;
            valueY += (int) ((max - lineValues.get(i)) * scale);
            valueX2 = (int) ((double)(i + 1) * (lineSpacing)) + sideOffset;
            valueY2 = topOffset;
            valueY2 += (int) ((max - lineValues.get(i + 1)) * scale);
            
            //draw legend info + lines and points
            g.setColor(Color.black);
            g.drawLine(valueX, valueY, valueX2, valueY2);
            g.drawRect(valueX - 3, valueY - 3, 6, 6);
            legendPosY = rectY + ((i + 1) * 60) - 30;
            g.drawRect(rectX + 5, legendPosY, 6, 6);
            g.setFont(legendFont);
            g.drawString(lineLabels.get(i), rectX + 16, legendPosY + (int) Math.rint((double)legendFontMetrics.getHeight() / 2.0));
            g.setFont(labelFont);
            g.setColor(colors[i]);
            g.fillRect(valueX - 3, valueY - 3, 6, 6);
            g.fillRect(rectX + 5, legendPosY, 6, 6);
            
            g.setColor(Color.black);
            labelWidth = labelFontMetrics.stringWidth("Sector #" + Integer.toString(i));
            l_x = (int) Math.rint((double)i * lineSpacing - ((double)labelWidth / 2.0)) + sideOffset;
            g.drawString("Sector #" + Integer.toString(i + 1), l_x, l_y);
            g.drawLine(valueX, clientHeight - bottomOffset + 3, valueX, topOffset);
            
            //Last data point
            if(i == lineValues.size() - 2)
            {
                g.drawRect(valueX2 - 3, valueY2 - 3, 6, 6);
                g.drawRect(rectX + 5, rectY + ((i + 2) * 60) - 30, 6, 6);
                g.setFont(legendFont);
                g.drawString(lineLabels.get(i + 1), rectX + 16, rectY + ((i + 2) * 60) - 30 + (int) Math.rint((double)legendFontMetrics.getHeight() / 2.0));
                g.setFont(labelFont);
                g.setColor(colors[i + 1]);
                g.fillRect(valueX2 - 3, valueY2 - 3, 6, 6);
                g.fillRect(rectX + 5, rectY + ((i + 2) * 60) - 30, 6, 6);
                
                g.setColor(Color.black);
                l_x = (int) Math.rint((double)(i + 1) * lineSpacing - ((double)labelWidth / 2.0)) + sideOffset;
                g.drawString("Sector #" + Integer.toString(i + 2), l_x, l_y);
                g.drawLine(valueX2, clientHeight - bottomOffset + 3, valueX2, topOffset);
            }
        }
        
        g.setColor(Color.black);
        //get closest value to max for y plot
        int closeMax = 0;
        for (int j = maxInt; j > 0; j--)
        {
            if(j % yStepSize == 0)
            {
                closeMax = j;
                break;
            }
        }
        
        int lines = closeMax / yStepSize;
        int linePosY;
        int s_y;
        for(int l = 1; l < lines + 1; l++)
        {
            linePosY = topOffset + (int) (((double)max - (l * yStepSize)) * scale);
            g.drawLine(sideOffset-3, linePosY, clientWidth - otherSideOffset, linePosY);
            s_y = linePosY + (int) ((double)labelFontMetrics.getAscent() / 2.0);
            g.drawString("$" + Integer.toString(l * yStepSize), 5, s_y);
        }
        
        //Graph outline
        g.drawRect(sideOffset, topOffset, clientWidth - sideOffset - otherSideOffset, clientHeight - topOffset - bottomOffset);
        
        //Legend outline
        g.drawRect(rectX, rectY, rectWidth, rectHeight);
    }

    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JLabel jLabel1;
    // End of variables declaration//GEN-END:variables
}
